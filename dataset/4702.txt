From: chongo@toad.com (Landon C. Noll) Subject: 10th International Obfuscated C Code Contest Opening (part 2 of 2)  Enclosed are the rules, guidelines and related information for the 10th International Obfuscated C Code Contest.  (This is part 2 of a 2 part shar file).  Enjoy!  chongo  / oo/  Larry Bassel  =-=      This is part 02 of a multipart archive   ============= mkentry.c ============== echo  x - extracting mkentry.c (Text)  sed  is/^X//\'  mkentry.c && X/*  \t1.24 3/1/93 02:28:49 */ X/* X * Copyright (c) Landon Curt Noll & Larry Bassel, 1993.   X * All Rights Reserved.  Permission for personal, education or non-profit use  X * is granted provided this this copyright and notice are included in its  X * entirety and remains unaltered.  All other uses must receive prior  X * permission in writing from both Landon Curt Noll and Larry Bassel. X */ X/* X * mkentry - make an International Obfuscated C Code Contest entry X * X * usage: X *\tmkentry -r remarks -b build -p prog.c -o ioccc.entry X * X *\t-r remarks\t\tfile with remarks about the entry X *\t-b build\t\tfile containing how prog.c should be built X *\t-p prog.c\t\tthe obfuscated program source file X *\t-o ioccc.entry\t\tioccc entry output file X * X * compile by: X *\tcc mkentry.c -o mkentry X */ X/* X * Placed in the public domain by Landon Curt Noll, 1992. X * X * THIS SOFTWARE IS PROVIDED ``AS IS\'\' AND WITHOUT ANY EXPRESS OR IMPLIED X * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF X * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. X */ X/* X * WARNING: X * X * This program attempts to implement the IOCCC rules.  Every attempt X * has been made to make sure that this program produces an entry that X * conforms to the contest rules.  In all cases, where this program X * differs from the contest rules, the contest rules will be used.  Be X * sure to check with the contest rules before submitting an entry. X * X * Send questions or comments (but not entries) about the contest, to: X * X *\t...!{sun,pacbell,uunet,pyramid}!hoptoad!judges X *\tjudges@toad.com X * The rules and the guidelines may (and often do) change from year to X * year.  You should be sure you have the current rules and guidelines X * prior to submitting entries.  To obtain all 3 of them, send Email X * to the address above and use the subject  isend rules\'. X * X * Because contest rules change from year to year, one should only use this X * program for the year that it was intended.  Be sure that the RULE_YEAR X * define below matches this current year. X */ X X include  X include  X include  X include  X include  X X/* logic */ X ifndef TRUE X  define TRUE 1 X endif /* TRUE */ X ifndef FALSE X  define FALSE 0 X endif /* FALSE */ X define EOF_OK TRUE X define EOF_NOT_OK FALSE X X/* global limits */ X define RULE_YEAR 1993\t\t/* NOTE: should match the current year */ X define START_DATE  1Mar92 0:00 UTC \t/* first confirmation received */ X define MAX_COL 79\t\t/* max column a line should hit */ X define MAX_BUILD_SIZE 256\t/* max how to build size */ X define MAX_PROGRAM_SIZE 3217\t/* max program source size */ X define MAX_PROGRAM_SIZE2 1536\t/* max program source size not counting X\t\t\t\t   whitespace and {}; not followed by X\t\t\t\t   whitespace or EOF */ X define MAX_TITLE_LEN 12\t/* max chars in the title */ X define MAX_ENTRY_LEN 1\t\t/* max length in the entry input line */ X define MAX_ENTRY 8\t\t/* max number of entries per person per year */ X define MAX_FILE_LEN 1024\t/* max filename length for a info file */ X X/* where to send entries */ X define ENTRY_ADDR1  ...!{apple,pyramid,sun,uunet}!hoptoad!obfuscate  X define ENTRY_ADDR2  obfuscate@toad.com  X X/* uuencode process - assumes ASCII */ X define UUENCODE(c) (encode_str[(int)(c)&0xff]) X define UUENCODE_LEN 45\t\t/* max uuencode chunk size */ X define UUINFO_MODE 0444\t/* mode of an info file is uuencode file */ X define UUBUILD_MODE 0444\t/* mode of the build file is uuencode file */ X define UUBUILD_NAME  build \t/* name for the build file is uuencode file */ X define UUPROG_MODE 0444\t/* mode of the program is uuencode file */ X define UUPROG_NAME  prog.c \t/* name for the program is uuencode file */ X X/* encode_str[(char)val] is the uuencoded character of val */ Xchar encode_str[256+1] =  `!     ]^_ !     ]^_ !     ]^_ !     ]^_ ; X X/* global declarations */ Xchar *program;\t\t\t/* our name */ Xlong start_time;\t\t/* the startup time */ X X/* forward declarations */ Xvoid parse_args(); Xvoid usage(); XFILE *open_remark(); XFILE *open_build(); XFILE *open_program(); XFILE *open_output(); Xvoid output_entry(); Xvoid output_remark(); Xvoid output_author(); Xvoid output_info(); Xvoid output_build(); Xvoid output_program(); Xvoid output_end(); Xint get_line(); Xvoid output_till_dot(); Xint col_len(); Xvoid check_io(); Xvoid uuencode(); X Xmain(argc, argv) X    int argc;\t\t/* arg count */ X    char **argv;\t/* the args */ X{ X    FILE *remark=NULL;\t/* open remarks stream */ X    FILE *build=NULL;\t/* open build file stream */ X    FILE *prog=NULL;\t/* open program stream */ X    FILE *output=NULL;\t/* open output stream */ X    char *rname=NULL;\t/* file with remarks about the entry */ X    char *bname=NULL;\t/* file containing how prog.c should be built */ X    char *pname=NULL;\t/* the obfuscated program source file */ X    char *oname=NULL;\t/* ioccc entry output file */ X    struct tm *tm;\t/* startup time structure */ X X    /* X     * check on the year X     */ X    start_time = time((long *)0); X    tm = gmtime(&start_time); X    if (tm->tm_year != RULE_YEAR-1900) { X\tfprintf(stderr, X\t %s: WARNING: this program applies to %d, which may differ from %d n n , X\t    argv[0], RULE_YEAR, 1900+tm->tm_year); X    } X X    /* X     * parse the command line args X     */ X    parse_args(argc, argv, &rname, &bname, &pname, &oname); X X    /* X     * open/check the input and output files X     * X     * We open and truncate the output file first, in case it is the same X     * as one of the input files. X     */ X    output = open_output(oname); X    remark = open_remark(rname); X    build = open_build(bname); X    prog = open_program(pname); X    if (output==NULL || remark==NULL || build==NULL || prog==NULL) { X\texit(1); X    } X X    /* X     * output each section X     */ X    output_entry(output, oname); X    output_remark(output, oname, remark, rname); X    output_author(output, oname); X    output_info(output, oname); X    output_build(output, oname, build, bname); X    output_program(output, oname, prog, pname); X    output_end(output, oname); X X    /*  X     * flush the output  X     */ X    if (fflush(output) == EOF) { X\tfprintf(stderr,  %s: flush error in %s:  , program, oname); X\tperror(  ); X\texit(2); X    } X X    /* X     * final words X     */ X    printf(  nYour entry can be found in %s.  You should check this file n ,  X\toname); X    printf( correct any problems and verify that the uudecode utility will n ); X    printf( correctly decode your build file and program. n n ); X    printf( This program has been provided as a guide for submitters.  In n ); X    printf( cases where it conflicts with the rules, the rules shall apply. n ); X    printf( It is your responsibility to ensure that your entry conforms to n ); X    printf( the current rules. n n ); X    printf( Email your entries to: n ); X    printf(  t%s n , ENTRY_ADDR1); X    printf(  t%s n n , ENTRY_ADDR2); X    printf( Please use the following subject when you Email your entry: n ); X    printf(  tioccc entry n n ); X    /* all done */ X    exit(0); X} X X/* X * parse_args - parse the command line args X * X * Given the command line args, this function parses them and sets the X * required name flags.  This function will return only if the command X * line syntax is correct. X */ Xvoid Xparse_args(argc, argv, rname, bname, pname, oname) X    int argc;\t\t/* arg count */ X    char **argv;\t/* the args */ X    char **rname;\t/* file with remarks about the entry */ X    char **bname;\t/* file containing how prog.c should be built */ X    char **pname;\t/* the obfuscated program source file */ X    char **oname;\t/* ioccc entry output file */ X{ X    char *optarg;\t/* -flag option operand */ X    int flagname;\t/* the name of the -flag */ X    int i; X X    /* X     * Not everyone has getopt, so we must parse args by hand. X     */ X    program = argv[0]; X    for (i=1; i = argc) { X\t\tusage(2); X\t\t/*NOTREACHED*/ X\t    } else { X\t\toptarg = argv[++i]; X\t    } X\t} X X\t/* save the flag is operand in the correct global variable */ X\tswitch (flagname) { X\tcase \'r\': X\t    *rname = optarg; X\t    break; X\tcase \'b\': X\t    *bname = optarg; X\t    break; X\tcase \'p\': X\t    *pname = optarg; X\t    break; X\tcase \'o\': X\t    *oname = optarg; X\t    break; X\tdefault: X\t    usage(3); X\t    /*NOTREACHED*/ X\t} X    } X X    /* X     * verify that we have all of the required flags X     */ X    if (*rname == NULL || *bname == NULL || *pname == NULL || *oname == NULL) { X\tusage(4); X\t/*NOTREACHED*/ X    } X    return; X} X X/* X * usage - print a usage message and exit X * X * This function does not return. X */ Xvoid Xusage(exitval) X    int exitval;\t\t/* exit with this value */ X{ X    fprintf(stderr, X\t usage: %s -r remarks -b build -p prog.c -o ioccc.entry n n , program); X    fprintf(stderr,   t-r remarks tfile with remarks about the entry n ); X    fprintf(stderr,   t-b build tfile containing how prog.c should be built n ); X    fprintf(stderr,   t-p prog.c tthe obfuscated program source file n ); X    fprintf(stderr,   t-o ioccc.entry tioccc entry output file n ); X    exit(exitval); X} X X/* X * open_remark - open/check the remark file X * X * The remark file should be indented by 4 spaces, and should not extend  X * beyond column MAX_COL.  These are not requirements, so we only warn. X * X * This function returns NULL on I/O or format error. X */ XFILE * Xopen_remark(filename) X    char *filename; X{ X    FILE *stream;\t\t/* the opened file stream */ X    char buf[BUFSIZ+1];\t\t/* input buffer */ X    int toolong=0;\t\t/* number of lines that are too long */ X    int non_indent=0;\t\t/* number of lines not indented by 4 spaces */ X X    /* X     * open the remark input file X     */ X    stream = fopen(filename,  r ); X    if (stream == NULL) { X\tfprintf(stderr,  %s: cannot open remark file: %s:  , X\t    program, filename); X\tperror(  ); X\treturn(NULL); X    } X X    /* X     * look at each line X     */ X    while (fgets(buf, BUFSIZ, stream) != NULL) { X X\t/* count lines that do not start with 4 spaces */ X\tif (buf[0] != \' n\' && strncmp(buf,       , 4) != 0) { X\t    ++non_indent; X\t} X X\t/* count long lines */ X\tif (col_len(buf) > MAX_COL) { X\t    /* found a line that is too long */ X\t    ++toolong; X\t} X    } X X    /* watch for I/O errors */ X    check_io(stream, filename, EOF_OK); X X    /* note long lines if needed */ X    if (toolong > 0) { X\tfprintf(stderr, X\t     %s: WARNING: %d line(s) from %s extend beyond the 80th column n , X\t    program, toolong, filename); X\tfprintf(stderr, X\t     %s:          This is ok, but it would be nice to avoid n n , X\t    program); X    } X X    /* note non-indented lines, if needed */ X    if (non_indent > 0) { X\tfprintf(stderr, X\t     %s: WARNING: %d line(s) from %s are not indented by 4 spaces n , X\t    program, non_indent, filename); X\tfprintf(stderr, X\t     %s:          This is ok, but it would be nice to avoid n n , X\t    program); X    } X X    /* return the open file */ X    rewind(stream); X    return(stream); X} X X/* X * open_build - open/check the build file X * X * The how to build file must not be longer than MAX_BUILD_SIZE bytes. X * X * This function returns NULL on I/O or size error. X */ XFILE * Xopen_build(filename) X    char *filename; X{ X    FILE *stream;\t\t/* the opened file stream */ X    struct stat statbuf;\t/* the status of the open file */ X X    /* X     * open the how to build input file X     */ X    stream = fopen(filename,  r ); X    if (stream == NULL) { X\tfprintf(stderr,  %s: cannot open how to build file: %s:  , X\t    program, filename); X\tperror(  ); X\treturn(NULL); X    } X X    /* X     * determine the size of the file X     */ X    if (fstat(fileno(stream), &statbuf)  MAX_BUILD_SIZE) { X\tfprintf(stderr, X\t     %s: FATAL: the how to build file: %s, is %d bytes long n , X\t    program, filename, statbuf.st_size); X\tfprintf(stderr, X\t     %s:        it may not be longer than %d bytes n , X\t    program, MAX_BUILD_SIZE); X\treturn(NULL); X    } X X    /* return the open file */ X    return(stream); X} X X/* X * open_program - open/check the program source file X * X * The program source file must be  MAX_PROGRAM_SIZE) { X\tfprintf(stderr, X\t     %s: FATAL: the program source file: %s, is %d bytes long n , X\t    program, filename, statbuf.st_size); X\tfprintf(stderr, X\t     %s:        it may not be longer than %d bytes n , X\t    program, MAX_PROGRAM_SIZE); X\treturn(NULL); X    } X X    /* X     * count the non-whitespace, non {}; followed by whitespace chars X     */ X    count = 0; X    c = 0; X    while ((c=fgetc(stream)) != EOF) { X\t/* look at non-whitespace */ X\tif (!isascii(c) || !isspace(c)) { X\t    switch (c) { X\t    case \'{\':\t\t/* count if not followed by EOF or whitespace */ X\t    case \'}\': X\t    case \';\': X\t\t/* peek at next char */ X\t\tc = fgetc(stream); X\t\tif (c != EOF && isascii(c) && !isspace(c)) { X\t\t    /* not followed by whitespace or EOF, count it */ X\t\t    ungetc(c, stream); X\t\t    ++count; X\t\t} X\t\tbreak; X\t    default: X\t\t++count; X\t\tbreak; X\t    } X\t} X    } X X    /* watch for I/O errors */ X    check_io(stream, filename, EOF_OK); X X    /* look at the special size */ X    if (count > MAX_PROGRAM_SIZE2) { X\tfprintf(stderr, X\t     %s: FATAL: the number of bytes that are non-whitespace, and n , X\t    program); X\tfprintf(stderr, X\t     %s:        that are not \'{\', \'}\', \';\' followed by whitespace n , X\t    program); X\tfprintf(stderr, X\t     %s:        or EOF must be  the line is not ok */ X    char skip;\t\t\t\t/* input to skip */ X    FILE *date_pipe;\t\t\t/* pipe to a date command */ X    time_t epoch_sec;\t\t\t/* seconds since the epoch */ X    char *p; X X    /* X     * write the start of the section X     */ X    fprintf(output,  ---entry--- n ); X    check_io(output, oname, EOF_NOT_OK); X X    /* X     * write the rule year X     */ X    fprintf(output,  rule: t%d n , RULE_YEAR); X    check_io(output, oname, EOF_NOT_OK); X X    /* determine if this is a fix */ X    printf( Is this a fix, update or resubmittion to a  ); X    printf( previous entry (enter y or n)?  ); X    while (get_line(buf, 1+1, 0)  MAX_ENTRY-1) { X\t    printf( X\t        nThe entry number must be between 0 and %d inclusive n n , X\t\tMAX_ENTRY-1); X\t    printf( enter the entry number:  ); X\t} X    } while (ret != 1 || entry  MAX_ENTRY-1); X    fprintf(output,  entry: t%d n , entry); X    check_io(output, oname, EOF_NOT_OK); X X    /* X     * write the submission date X     */ X    /* returns a newline */ X    epoch_sec = time(NULL); X    fprintf(output,  date: t%s , asctime(gmtime(&epoch_sec))); X    check_io(output, oname, EOF_NOT_OK); X X    /* X     * write the OS/machine host information X     */ X    printf( X        nEnter the machine(s) and OS(s) under which your entry was tested. n ); X    output_till_dot(output, oname,  host: ); X} X X/* X * output_remark - output the ---remark--- section X * X * Read the needed information form stdin, and write the entry section. X */ Xvoid Xoutput_remark(output, oname, remark, rname) X    FILE *output;\t\t/* entry is output file stream */ X    char *oname;\t\t/* name of the output file */ X    FILE *remark;\t\t/* stream to the file containing remark text */ X    char *rname;\t\t/* name of the remark file */ X{ X    char buf[BUFSIZ+1];\t\t/* input/output buffer */ X X    /* X     * write the start of the section X     */ X    fprintf(output,  ---remark--- n ); X    check_io(output, oname, EOF_NOT_OK); X X    /* X     * copy the remark file to the section X     */ X    while (fgets(buf, BUFSIZ, remark) != NULL) { X\tfputs(buf, output); X\tcheck_io(output, oname, EOF_NOT_OK); X    } X    check_io(remark, rname, EOF_OK); X X    /* be sure that the remark section ends with a newline */ X    if (buf[strlen(buf)-1] != \' n\') { X\tfputc(\' n\', output); X\tcheck_io(output, oname, EOF_NOT_OK); X    } X} X X/* X * output_author - output the ---author--- section X * X * Read the needed information from stdin, and write the author section. X * If multiple authors exist, multiple author sections will be written. X */ Xvoid Xoutput_author(output, oname) X    FILE *output;\t\t/* entry is output file stream */ X    char *oname;\t\t/* name of the output file */ X{ X    char buf[MAX_COL+1+1];\t/* I/O buffer */ X    int more_auths;\t\t/* TRUE => more authors to note */ X    int auth_cnt=0;\t\t/* number of authors processed */ X X    /* X     * prompt the user for the author section X     */ X    printf(  nEnter information about each author.  If your entry is after n ); X    printf( %s and before the contest deadline, the judges n , START_DATE); X    printf( will attempt to Email back a confirmation to the first author n ); X X    /* X     * place author information for each author in an individual section X     */ X    do { X X\t/* write the start of the section */ X\tfprintf(output,  ---author--- n ); X\tcheck_io(output, oname, EOF_NOT_OK); X X\t/* write the author */ X\tprintf(  nAuthor  %d name:  , ++auth_cnt); X\twhile (get_line(buf, MAX_COL+1, MAX_COL-9)  infoname; --uuname) { X\t    if (*uuname == \'/\') { X\t\t++uuname; X\t\tbreak; X\t    } X\t} X X\t/* attempt to open the info file */ X\tinfile = fopen(infoname,  r ); X\tif (infile == NULL) { X\t    fprintf(stderr,   n%s: cannot open info file: %s:  , X\t\tprogram, infoname); X\t    perror(  ); X\t    continue; X\t} X X\t/* X\t * write the start of the section X\t */ X\tfprintf(output,  ---info--- n ); X\tcheck_io(output, oname, EOF_NOT_OK); X X\t/* uuencode the info file */ X\tuuencode(output, oname, infile, infoname, UUINFO_MODE, uuname); X X\tprintf(  nDo you have another info file to include (enter y or n)?  ); X\twhile (get_line(yorn, 1+1, 0)  disable check */ X{ X    int length;\t\t\t/* the length of the input line */ X X    /* flush terminal output */ X    fflush(stdout); X X    /* read the line */ X    if (fgets(buf, siz+1, stdin) == NULL) { X\t/* report the problem */ X\tcheck_io(stdin,  stdin , EOF_NOT_OK); X    } X X    /* look for the newline */ X    length = strlen(buf); X    if (buf[length-1] != \' n\') { X\tint eatchar;\t\t/* the char being eaten */ X X\t/* no newline found, line must be too long, eat the rest of the line */ X\tdo { X\t    eatchar = fgetc(stdin); X\t} while (eatchar != EOF && eatchar != \' n\'); X\tcheck_io(stdin,  stdin , EOF_NOT_OK); X X\t/* report the situation */ X\treturn 0; X    } X X    /* watch for long lines, if needed */ X    if (maxcol > 0 && (length > maxcol || col_len(buf) > maxcol)) { X\t/* report the situation */ X\treturn 0; X    } X X    /* return length */ X    return length; X} X X/* X * output_till_dot - output a set of lines until \'.\' by itself is read X * X * This routine will read a set of lines until (but not including) X * a single line with \'.\' is read.  The format of the output is: X * X *\tleader: tfirst line X *\t tnext line X *\t tnext line X *\t   ... X * X * This routine will not return if I/O error or EOF. X */ Xvoid Xoutput_till_dot(output, oname, leader) X    FILE *output;\t\t/* entry is output file stream */ X    char *oname;\t\t/* name of the output file */ X    char *leader;\t\t/* the lead text for the first line */ X{ X    char buf[BUFSIZ+1];\t\t/* input buffer */ X    int count;\t\t\t/* lines read */ X    int done=FALSE;\t\t/* TRUE => finished reading input */ X X    /* instruct the user on how to input */ X    printf(  nTo end input, enter a line with a single period. n ); X X    /* read lines until \'.\' or EOF */ X    count = 0; X    while (!done) { X\t/* issue the prompt */ X\tprintf( %s t , (count>0) ?    : leader); X\tfflush(stdout); X X\t/* get the line */ X\tif (get_line(buf, BUFSIZ, MAX_COL-9) 0) ?    : leader, buf); X\t    check_io(output, oname, EOF_NOT_OK); X\t} X    } X X    /* if no lines read, at least output something */ X    if (count  0) { X\t X\t/* X\t * the first character is the length character X\t */ X\tfputc(UUENCODE(read_len), output); X\tcheck_io(output, oname, EOF_NOT_OK); X X\t/* X\t * We will convert 24 bits at a time.  Thus we will convert X\t * 3 sets of 8 bits into 4 sets of uuencoded 6 bits. X\t */ X\tfor (p=buf; read_len>0; read_len-=3, p+=3) { X X\t    /* bits 0 to 5 */ X\t    val = (p[0]>>2)&0x3f; X\t    fputc(UUENCODE(val), output); X\t    check_io(output, oname, EOF_NOT_OK); X X\t    /* bits 6 to 11 */ X\t    val = ((p[0]>4)&0x0f); X\t    fputc(UUENCODE(val), output); X\t    check_io(output, oname, EOF_NOT_OK); X X\t    /* bits 12 to 17 */ X\t    val = ((p[1]>6)&0x03); X\t    fputc(UUENCODE(val), output); X\t    check_io(output, oname, EOF_NOT_OK); X X\t    /* bits 18 to 23 */ X\t    val = p[2]&0x3f; X\t    fputc(UUENCODE(val), output); X\t    check_io(output, oname, EOF_NOT_OK); X\t} X X\t/* end of UUENCODE_LEN line */ X\tfputc(\' n\', output); X\tcheck_io(output, oname, EOF_NOT_OK); X X\t/* X\t * clear out the input buffer  (do not depend on bzero() or memset()) X\t */ X\tfor (p=buf; p  obfuscate.info && X1993 Obfuscated contest information X XCopyright (c) Landon Curt Noll & Larry Bassel, 1993.   XAll Rights Reserved.  Permission for personal, education or non-profit use is  Xgranted provided this this copyright and notice are included in its entirety  Xand remains unaltered.  All other uses must receive prior permission in writing  Xfrom both Landon Curt Noll and Larry Bassel. X XThe International Obfuscated C Code Contest (IOCCC), in the sprit of Xco-operation, is willing mention other programming contents, as space Xpermits.   X XHow to have your contest included in this file: X X    If you wish the IOCCC judges to include your contest in this file, X    send a request to: X X\tjudges@toad.com X X    We request that contest descriptions be limited to 50 lines and to X    not exceed 2500 bytes.  We typically request that your contest X    include a current description of the IOCCC. X X    In order to be included in this file for given year, we must X    receive a current description no EARLIER than Jan 1 00:00:00 UTC and X    no LATER than Feb 15 00:00:00 UTC.  Agreement to publish your X    contest must also be obtained prior to Feb 15.  Annual contests X    that fail to submit a new entry will be dropped from this file. X XOfficial Disclaimer:  (pardon the officialese) X X    The contents noted below, other than the IOCCC, are not affiliated  X    with the IOCCC, nor are they endorsed by the IOCCC.  We reserve the  X    right to refuse to print information about a given contest. X X    The information below was provided by the particular contest X    organizer(s) and printed by permission.  Please contact the X    contest organizer(s) directly regarding their contents. X XWith that official notice given, we present for your ENJOYMENT, the following Xinformation about contents: X X--------------------------------------------------------------------------- X X    10th International Obfuscated C Contest    X     X\t The original obfuscated contest  X X    Obfuscate:  tr.v.  -cated, -cating, -cates.  1. a.  To render obscure. X                b.  To darken.  2. To confuse:  Their emotions obfuscated  X\t\ttheir judgment.  [LLat. obfuscare, to darken : ob(intensive) + X                Lat. fuscare, to darken < fuscus, dark.] -obfuscation n. X                obfuscatory adj. X  X    GOALS OF THE CONTEST: X  X        * To write the most Obscure/Obfuscated C program under the rules below. X        * To show the importance of programming style, in an ironic way. X        * To stress C compilers with unusual code. X        * To illustrate some of the subtleties of the C language. X        * To provide a safe forum for poor C code.  :-) X  X    The IOCCC is the grandfather of USENET programming contests.  Since X    1984, this contest demonstrated that a program that mearly works X    correctly is not sufficient.  The IOCCC has also done much to add X    the arcane word \'obfuscated\' back into the English language. X    (see  The New Hacker is Dictionary  by Eric Raymond) X  X    You are strongly encouraged to read the new contest rules before X    sending any entries.  The rules, and sometimes the contest Email X    address itself, change over time.  A valid entry one year may X    be rejected in a later year due to changes in the rules.  The typical X    start date for contests is in early March.  Contest rules are normally not X    finalized and posted until the beginning of the contest.  The typical  X    closing date for contests are in early May. X  X    The contest rules are posted to comp.unix.wizards, comp.lang.c, X    misc.misc, alt.sources and comp.sources.d.  If you do not have access  X    to these groups, or if you missed the early March posting, you may  X    request a copy from the judges, via Email, at; X  X        judges@toad.com   -or-   ...!{sun,uunet,utzoo,pyramid}!hoptoad!judges X  X    Previous contest winners are available via anonymous ftp from X    ftp.uu.net under the directory /pub/ioccc. X X--------------------------------------------------------------------------- X X    0th International Obfuscated Perl Contest X\tBy: Landon Noll & Larry Wall X X    This content is being planned.  Someday when Landon & Larry are not too  X    busy, they will actually get around to posting the first set of rules! X X    Landon says:  Yes, I know that I said we would have a contest in 1993, X\t\t  but other existing projects got in the way.  Hopefully X\t\t  something will be developed after Nov 1993.  X X--------------------------------------------------------------------------- X X                2nd International obFUsCaTeD POsTsCripT Contest X                     Jonathan Monsarrat (jgm@cs.brown.edu) X                         Alena Lacova (alena@nikhef.nl) X X    A  contest of  programming skills  and  knowledge, exclusively  for the X    PostScript programming language. Its purpose: X X    * To spread knowledge of PostScript and its details. X    * To applaud those with the best tricks. X    * To prove  that humans can  beat those damnable  machine generators at X      their own game by writing  the most obscure and mysterious PostScript X      programs ever. X X    Winners will receive the fame and attention that goes with having their X    program entry posted as a winner to programmers world-wide. X X    The 1993 contest rules and results are available by ftp as X    ``wilma.cs.brown.edu:pub/postscript/obfuscated*.shar\'\', or individually X    in the obfuscated directory. The judges will post the 1994 rules X    in November to comp.lang.postscript on Usenet, and other places. X    Send questions to jgm@cs.brown.edu. X X    Categories include: Best Obfuscated PostScript, Best Artwork, X    Most Compact, Best Interactive Program, Most Useful, and X    anything so unusual and creative that it deserves an award. X X    The judges will choose the winners of each category. X X    Alena Lacova  is a system  administrator at NIKHEF  (Institute for High X    Energy and Nuclear  Physics) in the  Netherlands. She is  the author of X    The PostScript Chaos  Programs, which draw  Julia sets, Mandelbrot sets X    and other kinds of fractal functions. X X    Jonathan Monsarrat is a graduate  student from MIT and Brown University X    in  the  U.S.A. He  is  the  FAQ maintainer  for  the  Usenet newsgroup X    comp.lang.postscript and the author of The PostScript Zone and LameTeX. X . X SHAR_EOF chmod 0444 obfuscate.info || echo  restore of obfuscate.info failed  set `wc -c obfuscate.info`;Wc_c=$1 if test  $Wc_c  !=  6257 ; then \techo original size 6257, current size $Wc_c fi exit 0 --  Sunnyvale residents: Vote Landon Noll for Sunnyvale City Council seat 1. 