From: kaiser@informatik.uni-koblenz.de (Siegfried Kaiser) Subject: R5 table widget causing trouble with XtQueryGeometry  Contents:Problems with table widgets in R5  \tThe following part of a program (an user interface for a simulation \tsystem) did work in R4, but refused to in R5. Of cause, the R4-version \tdid not know about the xpTableWidgetClass (we used tableWidgetClass \t\t\tinstead - caught from the net in times of R3) and XpTableChildPosition \t\t\t(formerly XtTblPosition). \tSince compiling with R5, the program causes a zero width or height error \t(on sparc-stations). The trouble-shooter is the (re)computation of the \tmodel_init_table - table widget: though its childs (label and asciiText  \twidgets) exist, XtQueryGeometry returns a prefered width and height of \t\t\tzero.  \tThus the following asignment cannot perform anything else but set the \t\t\twidth and height of the newly created widget to zero. No wonder XtPopup \t\tor XtManage- Child create zero width or height errors (dependent on \t\t\twhether width and height of the shell widget are set in the resource \t\t\tfile or not). \t \tQuestion: Does anyone know, why XtQueryGeometry returns so low prefered \t\t\tvalues when working on table widgets or perhaps what \t\t\tto do about?  \ti shall be happy, if someone is able to help me.  \tGermans are requested to answer in german. \t \tSiegfried Kaiser \temail: kaiser@uniko.uni-koblenz.de  \t \tThe part of interest:   \t/* Graphischer Neuaufbau des Model-Init-Formulars */ \t\t/* Storing the old width and height of the viewport-\t*/ \t\t/* widget, which is the parent of the troubling table\t*/ \t\t/* widget, before the viewport widget is destroyed\t*/ \t\t/* The destroying of widgets before resizing them is a\t*/ \t\t/* relict from R3-age\t\t\t\t\t*/ \t \tif (model_init_popped_up)  \t\tXtUnmapWidget(model_init_form_view); \tXtDestroyWidget(model_init_form_view); \t \t\t/* Creating the subtree within the shell, of which the\t*/ \t\t/* root is the viewport widget\t\t\t\t*/ \t \tn = 0; \tXtSetArg(args[n],XtNfromVert,model_init_title); n++; \tXtSetArg(args[n],XtNfromHoriz,model_init_button_view); n++; \tXtSetArg(args[n],XtNallowVert,True); n++; \tXtSetArg(args[n],XtNforceBars,True); n++; \tmodel_init_form_view = XtCreateWidget( form_view ,viewportWidgetClass, \t\t\t\t\t      model_init_form,args,n);  \tn = 0; \tmodel_init_table = XtCreateWidget( table ,xpTableWidgetClass, \t\t\t\t\t  model_init_form_view,args,n);  \t\t/* create_form_widget does create and position table\t*/ \t\t/* widget is childs. To position them it uses XpTable-\t*/ \t\t/* ChildPosition in R5 and XtTblPosition in R4\t\t*/ \t\t\t\t\t  \tcreate_form_widget(ptr_model_init_obj,model_init_table);  \t\t/* \t\t\t\t\t\t\t*/ \t\t/* The crucial function call:\t\t\t\t*/ \t\t/* intended to return the maximum height possible: if\t*/ \t\t/* there is not sufficient space to show the whole table\t*/ \t\t/* widget, then the viewport shall grow as large as \t*/ \t\t/* possible, but not beyond the border of screen.\t*/ \t\t/* If there is enough space, the window is intended to\t*/ \t\t/* shrienk to the smallest possible height.\t\t*/ \t\t/*\t\t\t\t\t\t\t*/  \tXtQueryGeometry(model_init_table,NULL,&pref);  \t\t/* According to the algorithms idea, the new value of\t*/ \t\t/* viewport widget is height is selected. Unfortunately\t*/ \t\t/* pref.height = 0 leads to new_height = 0.\t\t*/ \t\t \tif (form_view_height > pref.height) new_height = pref.height; \telse new_height = form_view_height;  \t\t/* Setting the new values to viewport widgets ancestors\t*/  \tw = XtNameToWidget(model_init_form, form_view ); \tXtResizeWidget(w,width,new_height,pref.border_width); \tXtResizeWidget(model_init_form_view,width,new_height, \t\t       pref.border_width);  \tif (model_init_popped_up) \t{ \t\t/* In case the shell, which contains model_init_form_-\t*/ \t\t/* view and model_init_table, allready exists, is has\t*/ \t\t/* to be resized, too.\t\t\t\t\t*/ \t\t \t n = 0; \t XtSetArg(args[n],XtNwidth,&shell_width); n++; \t XtSetArg(args[n],XtNheight,&shell_height); n++; \t XtSetArg(args[n],XtNborderWidth,&shell_bw); n++; \t XtGetValues(model_init_shell,args,n); \t XtResizeWidget(model_init_shell,shell_width, \t\t\tshell_height - height + new_height,shell_bw); \t}; /* end of if */  \tn = 0; \tXtSetArg(args[n],XtNwidth,&width); n++; \tXtSetArg(args[n],XtNborderWidth,&bw); n++; \tXtGetValues(model_init_button_view,args,n); \tXtResizeWidget(model_init_button_view,width,new_height,bw);  \tXtResizeWidget(vert_bar,sbar_width,1,sbar_bw); \t \tresize_inits();  \t\t/* If there is the shell is height set within the \t*/ \t\t/* resource file, the program terminates within the\t*/ \t\t/* first XtManageChild on its second pass through the\t*/ \t\t/* observed function. The first pass succeeds.\t\t*/  \tXtManageChild(model_init_form_view); \tXtManageChild(model_init_table);   \tif (!model_init_popped_up) \t{ \t\t/* In case the shell is not popped up it has to be done.\t*/ \t\t/* If there is no value set to the shell is height within*/ \t\t/* the resource file, the program terminates here.\t*/ \t\t \t XtPopup(model_init_shell,XtGrabNone); \t model_init_pop_flag = True; \t set_model_init_attributes(); \t}; /* end of if */  \tget_actual_init(&ptr_actual); \tload_form(ptr_actual); \t \t \t \t/*\t\t\t\t\t\t\t\t*/ \t/* If someone suspects the creation of table widget is contents\t*/ \t/* causes all the trouble, there are the sources of create_form */ \t/*\t\t\t\t\t\t\t\t*/ \t \t\t \tcreate_form_widget(ptr,table) \tt_obj              *ptr; \tWidget             table; \t\t \t\t/* ptr is a linear list containing attributes and para-\t*/ \t\t/* meters of the model and additionally the correspon-\t*/ \t\t/* ding widgets\t\t\t\t\t\t*/ \t\t \t{ \t Arg               args[10]; \t int               n, \t\t\t   row, \t\t\t   col; \t t_obj             *ptr_obj; \t t_ident           *ptr_ident;  \t\t/* Initialization of the local variables\t\t*/ \t\t \t ptr_obj = ptr; \t col = 0; \t row = 0;   \t /* Schleife ueber die Objekte bzw. das Pseudo-Objekt (fuer die \t\t\t\tParameter) */ \t\t/* loop through the list of objects and pseudo-objects:\t*/ \t\t/* every object occuring in the model has zero or more\t*/ \t\t/* attributes and some parameters, which can be shared\t*/ \t\t/* by several objects. \t\t\t\t\t*/ \t\t/* Because of locality the attributes of one object are\t*/ \t\t/* listed in a second linear list (of type t_ident),\t*/ \t\t/* whereas the parameters, which can belong to any ob-\t*/ \t\t/* ject are put together in a pseudo-object \t\t*/ \t\t/* Thus the program loops through the list of objects\t*/ \t\t/* and pseudo-objects and for each object through the\t*/ \t\t/* list of its attributes resp. parameters.\t\t*/ \t\t \t while (ptr_obj != (t_obj*)NULL) \t { \t \t/* Each object and pseudo-object is represented in a\t*/ \t \t/* label widget\t\t\t\t\t\t*/ \t   \t  n = 0; \t  XtSetArg(args[n],XtNlabel,ptr_obj->name); n++; \t  ptr_obj->label_w = XtCreateManagedWidget( object ,labelWidgetClass, \t\t\t\t\t   table,args,n); \t  XpTableChildPosition(ptr_obj->label_w,col,row); \t  col++; \t  row++; \t  ptr_ident = ptr_obj->ident;  \t  /* Schleife ueber die Objekt-Attribute bzw. Parameter */ \t  while (ptr_ident != (t_ident*)NULL) \t  { \t  \t/* Each attribute and parameter is represented in a\t*/ \t  \t/* label and has a corresponding asciiText widget, in \t*/ \t  \t/* which it is to be initialized.\t\t\t*/ \t  \t \t   n = 0; \t   XtSetArg(args[n],XtNlabel,ptr_ident->name); n++; \t   ptr_ident->label_w = XtCreateManagedWidget( ident ,labelWidgetClass, \t\t\t\t\t      table,args,n); \t   XpTableChildPosition(ptr_ident->label_w,col,row); \t   col++;      \t   n = 0; \t   XtSetArg(args[n],XtNlength,ROW_LENGTH); n++; \t   XtSetArg(args[n],XtNstring,ptr_ident->text); n++; \t   XtSetArg(args[n],XtNeditType,XawtextEdit); n++; \t   XtSetArg(args[n],XtNwrap,XawtextWrapWord); n++; \t   XtSetArg(args[n],XtNresize,XawtextResizeHeight); n++; \t   XtSetArg(args[n],XtNuseStringInPlace,True); n++; \t   ptr_ident->text_w = XtCreateManagedWidget( text , \t\t\t\t\tasciiTextWidgetClass, \t\t\t\t\t     table,args,n); \t   XpTableChildPosition(ptr_ident->text_w,col,row); \t   col--; \t   row++; \t   get_next_ident(&ptr_ident); \t  }; /* end of while */ \t  col--; \t  get_next_obj(&ptr_obj); \t }; /* end of while */ \t} /* end of create_form_widget */   \t  So far the problem in detail.  